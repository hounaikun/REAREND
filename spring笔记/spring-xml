aop实现原理：aop底层采用代理机制进行实现
                1. 接口 + 实现类：spring采用jdk的动态代理Proxy。
                2. 实现类：spring采用 cglib字节码增强

aop术语：
1.target：目标类，需要被代理的类，例如：UserService
2.Joinpoint（连接点）：可能被拦截的方法,例如：所有方法
3.Pointcut（切入点）：已经增强的连接点 例如：addUser()
4.advice(通知/增强)：增强代码，例如：after()、before()
5.Weaving（织入）：把增强advice应用到目标对象target来创建新的代理对象proxy的过程
6.proxy 代理类
7.Aspect（切面）：是切入点pointcut和通知advice的结合

jdk动态代理：
	1.目标类：接口 + 实现类
	    public interface UserService {
	        void addUser();
	    }
	    @Service("userService")
	    public class UserServiceImpl implements UserService{
	        @Override
	        public void addUser() {
	            System.out.println("addUser");
	        }
	    }

	2.切面类：用于存通知MyAspect
	    @Component
	    public class MyAspect {
	        public void before(){
	            System.out.println("before");
	        }
	        public void after(){
	            System.out.println("after");
	        }
	    }

	3.工厂类：编写工厂生成代理
	    @Component
	    public class ProxyFactory {
	        //1.目标类
	        @Resource(name = "userService")
	        private UserService userService;

	        //2.切面类
	        @Autowired(required = false)
	        @Qualifier("myAspect")
	        private MyAspect myAspect;

	        /**
	         * 3.代理类：将目标类（切入点）和切面类（通知） 结合 -> 切面
	         *   Proxy.newProxyInstance
	         *      参数1：loader，类加载器，动态代理类 运行时创建，任何类都需要类加载器将其加载到内存
	         *              一般情况：当前类.class.getClassLoader();
	         *                      目标类示例.getClass().get...
	         *      参数2：Class[] interfaces 代理类需要实现的所有接口
	         *              方式1：目标类示例.getClass().getInterfaces(); 注意：只能获得自己接口，不能获得父元素接口
	         *              方式2：new Class[]{UserService.class}
	         *      参数3：InvocationHandler 处理类，接口，必须进行实现类，一般采用匿名内部类
	         *              提供invoke方法，代理类的每一个方法执行时，都将调用一次invoke
	         *                  参数31：Object proxy ： 代理对象
	         *                  参数32：Method method ： 代理对象当前执行的方法的描述对象（反射）
	         *                  参数33：Object[] args ：方法的实际参数
	         */
	         public UserService createProxy(){
	                return (UserService) Proxy.newProxyInstance(ProxyFactory.class.getClassLoader(), userService.getClass().getInterfaces(), new InvocationHandler() {
	                        @Override
	                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
	                                myAspect.before();
	                                Object obj = method.invoke(userService, args);
	                                myAspect.after();
	                                return obj;
	                         }
	                });
	        }
	   }
	4.测试
	@Test
	public void testJdk(){
	    ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("bean.xml");
	    ProxyFactory proxyFactory = applicationContext.getBean(ProxyFactory.class);
	    UserService userService = proxyFactory.createProxy();
	    userService.addUser();
	}

cglib字节码增强
	1.需要导入 cglib.jar 和 asm.jar 包 ；但是spring-core.jar 已经整合。
	2.目标类
	@Component
	public class Target {
	    public void addUser(){
	        System.out.println("add user....");
	    }
	}
	3.切面类
	@Component
	public class MyAspect {
	    public void before(){
	        System.out.println("before...");
	    }
	    public void after(){
	        System.out.println("after...");
	    }
	}
	4.工厂类
	@Component
	public class FactoryProxy {
	    @Resource(name="myAspect")
	    private MyAspect myAspect;
	    @Resource(name="target")
	    private Target target;

	    public Target createProxy(){
	        //1.核心类
	        Enhancer enhancer = new Enhancer();
	        //2.确定父类
	        enhancer.setSuperclass(Target.class);
	        //3.设置回调函数，MethodInterceptor 等效于 jdk InvocationHandler接口
	        //          intercept()等效于 invoke()
	        enhancer.setCallback(new MethodInterceptor() {
	            @Override
	            public Object intercept(Object proxy, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
	                myAspect.before();
	                Object obj = method.invoke(target, objects);
	                myAspect.after();
	                return obj;
	            }
	        });
	        //4.创建代理类
	        Target target = (Target) enhancer.create();
	        return target;
	    }
	}
	5.测试类
	public class TestT {
	    @Test
	    public void test01(){
	        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("bean.xml");
	        FactoryProxy factoryProxy = applicationContext.getBean("factoryProxy", FactoryProxy.class);
	        Target proxy = factoryProxy.createProxy();
	        proxy.addUser();
	    }
	}
	